# 开发自定义的登录流程

目前，在`passport`项目中，登录是由Security框架提供的页面的表单来输入用户名、密码，且由Security框架自动处理登录流程，不适合前后端分离的开发模式！所以，需要自行开发登录流程！

关于自定义的登录流程，主要需要：

- 在业务逻辑实现类中，调用Security的验证机制来执行登录认证
- 在控制器类中，自定义处理请求，用于接收登录请求及请求参数，并调用业务逻辑实现类来实现认证

**关于在Service中调用Security的认证机制：**

当需要调用Security框架的认证机制时，需要使用`AuthenticationManager`对象，可以在Security配置类中重写`authenticationManager()`方法，在此方法上添加`@Bean`注解，由于当前类本身是配置类，所以Spring框架会自动调用此方法，并将返回的结果保存到Spring容器中：

```java
@Bean
@Override
protected AuthenticationManager authenticationManager() throws Exception {
    return super.authenticationManager();
}
```

在`IAdminService`中添加处理登录的抽象方法：

```java
void login(AdminLoginDTO adminLoginDTO);
```

在`AdminServiceImpl`中，可以自动装配`AuthenticationManager`对象：

```java
@Autowired
private AuthenticationManager authenticationManager;
```

并实现接口中的方法：

```java
@Override
public void login(AdminLoginDTO adminLoginDTO) {
    // 日志
    log.debug("开始处理【管理员登录】的业务，参数：{}", adminLoginDTO);
    // 调用AuthenticationManager执行认证
    Authentication authentication = new UsernamePasswordAuthenticationToken(
            adminLoginDTO.getUsername(), adminLoginDTO.getPassword());
    authenticationManager.authenticate(authentication);
    log.debug("认证通过！");
}
```

**在控制器中接收登录请求，并调用Service：**

在根包下创建`pojo.dto.AdminLoginDTO`类：

```java
@Data
public class AdminLoginDTO implements Serializable {
    private String username;
    private String password;
}
```

在`AdminController`中添加处理请求的方法：

```java
@ApiOperation("管理员登录")
@ApiOperationSupport(order = 50)
@PostMapping("/login")
public JsonResult<Void> login(AdminLoginDTO adminLoginDTO) {
    log.debug("准备处理【管理员登录】的请求：{}", adminLoginDTO);
    adminService.login(adminLoginDTO);
    return JsonResult.ok();
}
```

为了保证能对以上路径直接发起请求，需要将此路径（`/admins/login`）添加到Security配置类的“白名单”中。

完成后，启动项目，可以通过Knife4j的调试来测试登录，当登录成功时将响应正确，当用户名或密码错误时，将响应错误（需要统一处理异常）。

**注意：即使登录成功，也不可以实现其它请求的访问！**

# 关于Session

HTTP协议本身是无状态协议，所以，无法识别用户的身份！

为了解决此问题，经编程时，引入了Session机制，用于保存用户的某些信息，可识别用户的身份！

Session的本身是在服务器端的内存中一个类似Map结构的数据，每个客户端在提交请求时，都会携带一个由服务器端首次响应时分配的Session ID，作为Map的Key，由于此Session ID具有极强的唯一性，所以，每个客户端的Session ID理论上都是不相同的，从而服务器可以识别客户端！

由于Session是保存在服务器端的内存中的，在一般使用时，并不适用于集群！

# Token

Token：令牌，票据。

目前，推荐使用Token来保存用户的身份标识，使之可以用于集群！

相比Session ID是没有信息含义的，Token则是有信息含义的数据，当客户端向服务器端提交登录请求后，服务器商认证通过就会将此用户的信息保存在Token中，并将此Token响应到客户端，后续，客户端在每次请求时携带Token，服务器端即可识别用户的身份！

# JWT

JWT = JSON Web Token

JWT是使用JSON格式表示一系列的数据的Token。

当需要使用JWT时，应该在项目中添加依赖：

```xml
<!-- JJWT（Java JWT） -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

然后，通过测试，实现生成JWT和解析JWT。

```java
@Slf4j
public class JwtTests {

    // 密钥（盐）
    String secretKey = "nmlfdasfdsaurefuifdknjfdskjhajhef";

    // 测试生成JWT
    @Test
    public void testGenerateJwt() {
        // 准备Claims
        Map<String, Object> claims = new HashMap<>();
        claims.put("id", 9527);
        claims.put("name", "liulaoshi");

        // JWT的组成部分：Header（头），Payload（载荷），Signature（签名）
        String jwt = Jwts.builder()
                // Header：用于声明算法与此数据的类型，以下配置的属性名是固定的
                .setHeaderParam("alg", "HS256")
                .setHeaderParam("typ", "jwt")
                // Payload：用于添加自定义数据，并声明有效期
                .setClaims(claims)
                .setExpiration(new Date(System.currentTimeMillis() + 3 * 60 * 1000))
                // Signature：用于指定算法与密钥（盐）
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();
        log.debug("JWT = {}", jwt);
        // eyJhbGciOiJIUzI1NiIsInR5cCI6Imp3dCJ9
        // .
        // eyJuYW1lIjoibGl1bGFvc2hpIiwiaWQiOjk1MjcsImV4cCI6MTY1OTkzMTUyMX0
        // .
        // TFyWBZ3l-y6rYbEYiVBbQjqnFNsFFR07K8lDES9TPs4

        // eyJhbGciOiJIUzI1NiIsInR5cCI6Imp3dCJ9.eyJuYW1lIjoibGl1bGFvc2hpIiwiaWQiOjk1MjcsImV4cCI6MTY1OTkzOTM0N30.7rj8Lhus1EYXUxE4Zy1wx1WFpbvxIQEmya3-A9WZP20
        // eyJhbGciOiJIUzI1NiIsInR5cCI6Imp3dCJ9.eyJuYW1lIjoibGl1bGFvc2hpIiwiaWQiOjk1MjcsImV4cCI6MTY1OTkzOTUzMH0.lwD_PzrqGXEgQs3KmMjsYzTmhsKbGhKnd1WkDkFpj5M
    }

    @Test
    public void testParseJwt() {
        String jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6Imp3dCJ9.eyJuYW1lIjoibGl1bGFvc2hpIiwiaWQiOjk1MjcsImV4cCI6MTY1OTkzOTUzMH0.lwD_PzrqGXEgQs3KmMjsYzTmhsKbGhKnd1WkDkFpj5M";
        Claims claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
        Object id = claims.get("id");
        Object name = claims.get("name");
        log.debug("id={}", id);
        log.debug("name={}", name);
    }

}
```

如果JWT数据已经过期，将出现错误：

```
io.jsonwebtoken.ExpiredJwtException: JWT expired at 2022-08-08T12:05:21Z. Current time: 2022-08-08T14:11:34Z, a difference of 7573854 milliseconds.  Allowed clock skew: 0 milliseconds.
```

如果JWT签名有误（JWT数据的最后一段出错，或生成与解析时使用的secretKey不同），将出现错误：

```
io.jsonwebtoken.SignatureException: JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.
```

如果JWT数据格式有误，将出现错误：

```
io.jsonwebtoken.MalformedJwtException: Unable to read JSON value: {"alg|b:"HS256","typ":"jwt"}
```



