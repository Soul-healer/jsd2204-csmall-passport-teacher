# 处理异常

在登录时，可能出现：

- 用户名错误：`BadCredentialsException`
- 密码错误：`BadCredentialsException`
- 账号被禁用：`DisabledException`

在访问时，可能出现：

- 无此权限：`AccessDeniedException`

以上异常都可以由统一处理异常的机制进行处理，则先在`ServiceCode`中添加对应的业务状态码：

```java
/**
 * 未授权的访问
 */
Integer ERR_UNAUTHORIZED = 40100;
/**
 * 未授权的访问：账号禁用
 */
Integer ERR_UNAUTHORIZED_DISABLED = 40101;
/**
 * 禁止访问，通常是已登录，但无权限
 */
Integer ERR_FORBIDDEN = 40300;
```

然后，在统一处理异常的类中，添加对相关异常的处理：

```java
@ExceptionHandler
public JsonResult<Void> handleBadCredentialsException(BadCredentialsException e) {
    String message = "登录失败，用户名或密码错误！";
    log.debug("处理BadCredentialsException：{}", message);
    return JsonResult.fail(ServiceCode.ERR_UNAUTHORIZED, message);
}

@ExceptionHandler
public JsonResult<Void> handleDisabledException(DisabledException e) {
    String message = "登录失败，此账号已禁用！";
    log.debug("处理DisabledException：{}", message);
    return JsonResult.fail(ServiceCode.ERR_UNAUTHORIZED_DISABLED, message);
}

@ExceptionHandler
public JsonResult<Void> handleAccessDeniedException(AccessDeniedException e) {
    String message = "访问失败，当前登录的账号无此权限！";
    log.debug("处理AccessDeniedException：{}", message);
    return JsonResult.fail(ServiceCode.ERR_FORBIDDEN, message);
}
```

另外，在解析JWT的过程中，也可能出现异常，由于解析JWT是在过滤器中进行的，如果出现异常，不会被统一处理异常的机制获取得到（因为过滤器执行的时间点太早），所以，只能在过滤器中自行处理异常，例如：

```java
// 尝试解析JWT
Claims claims = null;
try {
    claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
} catch (MalformedJwtException e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_PARSE, "无法获取到有效的登录信息，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
} catch (SignatureException e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_PARSE, "无法获取到有效的登录信息，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
} catch (ExpiredJwtException e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_EXPIRED, "登录信息已过期，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
} catch (Throwable e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_PARSE, "无法获取到有效的登录信息，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
}
```

# 添加管理员时分配角色

目前，当执行添加管理员时，并没有处理管理员的“角色”，以至于这些新添加的管理员没有权限！所以，添加管理员时，必须为管理员分配角色！

需要执行的任务：

- 修改`AdminAddNewDTO`，增加`Long[]`属性，用于表示客户端选择的若干种角色的id，使得Controller能接收客户端在“添加管理员”时选择的若干种角色
- 在Service中，需要调用Mapper实现“向管理员与角色的关联表中批量插入数据”
- 在Mapper层，需要实现“向管理员与角色的关联表中批量插入数据”

首先，实现Mapper层，需要执行的SQL语句大致是：

```mysql
insert into ams_admin_role (admin_id, role_id) values (?,?), (?,?) ... (?,?);
```

在根包下创建`mapper.AdminRoleMapper`接口（如果不存在，则创建，如果已存在，不需要重复创建），并在接口中添加抽象方法：

```java
int insertBatch(AdminRole[] adminRoleList);
```

在`AdminRoleMapper.xml`中配置以上抽象方法映射的SQL语句：

```xml
<!-- int insertBatch(AdminRole[] adminRoleList); -->
<insert id="insertBatch" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO ams_admin_role
    	(admin_id, role_id, gmt_create, gmt_modified)
    VALUES 
	<foreach collection="array" item="adminRole" separator=",">
        (#{adminRole.adminId}, #{adminRole.roleId}, 
        	#{adminRole.gmtCreate}, #{adminRole.gmtModified})
    </foreach>
</insert>
```

完成后，在`AdminRoleMapperTests`中编写并执行测试：

```java
@Test
public void testInsertBatch() {
    Long adminId = 5L;
    Long[] roleIds = {2L, 3L, 4L};
    LocalDateTime now = LocalDateTime.now();
    
    AdminRole[] adminRoleList = new AdminRole[roleIds.length];
    for (int i = 0; i < roleIds.length; i++) {
        AdminRole adminRole = new AdminRole();
        adminRole.setAdminId(adminId);
        adminRole.setRoleId(roleIds[i]);
        adminRole.setGmtCreate(now);
        adminRole.setGmtModified(now);
        adminRoleList[i] = adminRole;
    }
    
    int rows = mapper.insertBatch(adminRoleList);
    log.debug("批量插入管理员与角色的关联数据成功，受影响的行数={}", rows);
}
```

测试通过后，在`AdminAddNewDTO`类中补充`private Long[] roleIds;`属性：

```java
/**
 * 管理员关联到的若干个角色的id
 */
@ApiModelProperty("管理员关联到的若干个角色的id")
private Long[] roleIds;
```

然后，在`AdminServiceImpl`中，先自动装配`AdminRoleMapper`对象：

```java
@Autowired
private AdminRoleMapper adminRoleMapper;
```

并在“添加管理员”的业务的最后，补充向管理员与角色关联的表中插入数据：

```java
// 向管理员与角色关联的表中插入数据
log.debug("准备向管理员与角色关联的表中插入数据");
Long adminId = admin.getId();
Long[] roleIds = adminAddNewDTO.getRoleIds();
LocalDateTime now = LocalDateTime.now();

AdminRole[] adminRoleList = new AdminRole[roleIds.length];
for (int i = 0; i < roleIds.length; i++) {
    AdminRole adminRole = new AdminRole();
    adminRole.setAdminId(adminId);
    adminRole.setRoleId(roleIds[i]);
    adminRole.setGmtCreate(now);
    adminRole.setGmtModified(now);
    adminRoleList[i] = adminRole;
}
rows = adminRoleMapper.insertBatch(adminRoleList);
// 判断受影响的行数是否小于1（可能插入多条数据，所以，大于或等于1的值均视为正确）
if (rows < 1) {
    // 是：日志，抛出ServiceException
    String message = "添加管理员失败，服务器忙，请稍后再次尝试！[错误代码：2]";
    log.warn(message);
    throw new ServiceException(ServiceCode.ERR_INSERT, message);
}
```

完成后，修改原有的`AdminServiceTests`中添加管理员的测试方法，为测试数据补充`Long[] roleIds`属性的值，再进行测试：

```java
@Test
void testAddNew() {
    AdminAddNewDTO adminAddNewDTO = new AdminAddNewDTO();
    adminAddNewDTO.setUsername("test-admin-109");
    adminAddNewDTO.setPassword("123456");

    Long[] roleIds = {2L, 4L}; // 新增代码
    adminAddNewDTO.setRoleIds(roleIds); // 新增代码

    try {
        service.addNew(adminAddNewDTO);
        log.debug("添加管理员成功！");
    } catch (ServiceException e) {
        log.debug(e.getMessage());
    }
}
```





# 基于Spring JDBC的事务管理

事务：Transaction，是数据库中可以保障多次写（增删改）操作要么全部成功，要么全部失败的机制。

在基于Spring JDBC的数据库编程（包括使用Mybatis框架实现数据库编程）中，在处理业务的方法上添加`@Transactional`注解，即可保证此业务方法是事务性的。



```
向管理员表中插入数据

向管理员与角色表中插入数据
```



```
update 存款表 set 余额=余额-200000 where 账户='国斌老师';

update 存款表 set 余额=余额+200000 where 账户='苍松老师';
```









