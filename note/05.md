# 处理异常

在登录时，可能出现：

- 用户名错误：`BadCredentialsException`
- 密码错误：`BadCredentialsException`
- 账号被禁用：`DisabledException`

在访问时，可能出现：

- 无此权限：`AccessDeniedException`

以上异常都可以由统一处理异常的机制进行处理，则先在`ServiceCode`中添加对应的业务状态码：

```java
/**
 * 未授权的访问
 */
Integer ERR_UNAUTHORIZED = 40100;
/**
 * 未授权的访问：账号禁用
 */
Integer ERR_UNAUTHORIZED_DISABLED = 40101;
/**
 * 禁止访问，通常是已登录，但无权限
 */
Integer ERR_FORBIDDEN = 40300;
```

然后，在统一处理异常的类中，添加对相关异常的处理：

```java
@ExceptionHandler
public JsonResult<Void> handleBadCredentialsException(BadCredentialsException e) {
    String message = "登录失败，用户名或密码错误！";
    log.debug("处理BadCredentialsException：{}", message);
    return JsonResult.fail(ServiceCode.ERR_UNAUTHORIZED, message);
}

@ExceptionHandler
public JsonResult<Void> handleDisabledException(DisabledException e) {
    String message = "登录失败，此账号已禁用！";
    log.debug("处理DisabledException：{}", message);
    return JsonResult.fail(ServiceCode.ERR_UNAUTHORIZED_DISABLED, message);
}

@ExceptionHandler
public JsonResult<Void> handleAccessDeniedException(AccessDeniedException e) {
    String message = "访问失败，当前登录的账号无此权限！";
    log.debug("处理AccessDeniedException：{}", message);
    return JsonResult.fail(ServiceCode.ERR_FORBIDDEN, message);
}
```

另外，在解析JWT的过程中，也可能出现异常，由于解析JWT是在过滤器中进行的，如果出现异常，不会被统一处理异常的机制获取得到（因为过滤器执行的时间点太早），所以，只能在过滤器中自行处理异常，例如：

```java
// 尝试解析JWT
Claims claims = null;
try {
    claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwt).getBody();
} catch (MalformedJwtException e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_PARSE, "无法获取到有效的登录信息，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
} catch (SignatureException e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_PARSE, "无法获取到有效的登录信息，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
} catch (ExpiredJwtException e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_EXPIRED, "登录信息已过期，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
} catch (Throwable e) {
    log.warn("解析JWT失败：{}：{}", e.getClass().getName(), e.getMessage());
    JsonResult<Void> jsonResult = JsonResult.fail(
            ServiceCode.ERR_JWT_PARSE, "无法获取到有效的登录信息，请重新登录！");
    String jsonResultString = JSON.toJSONString(jsonResult);
    PrintWriter writer = response.getWriter();
    writer.println(jsonResultString);
    writer.close();
    return;
}
```

# 添加管理员时分配角色

目前，当执行添加管理员时，并没有处理管理员的“角色”，以至于这些新添加的管理员没有权限！所以，添加管理员时，必须为管理员分配角色！

需要执行的任务：

- 修改`AdminAddNewDTO`，增加`Long[]`属性，用于表示客户端选择的若干种角色的id，使得Controller能接收客户端在“添加管理员”时选择的若干种角色
- 在Service中，需要调用Mapper实现“向管理员与角色的关联表中批量插入数据”
- 在Mapper层，需要实现“向管理员与角色的关联表中批量插入数据”

首先，实现Mapper层，需要执行的SQL语句大致是：

```mysql
insert into ams_admin_role (admin_id, role_id) values (?,?), (?,?) ... (?,?);
```

在根包下创建`mapper.AdminRoleMapper`接口（如果不存在，则创建，如果已存在，不需要重复创建），并在接口中添加抽象方法：

```java
int insertBatch(AdminRole[] adminRoleList);
```

在`AdminRoleMapper.xml`中配置以上抽象方法映射的SQL语句：

```xml
<!-- int insertBatch(AdminRole[] adminRoleList); -->
<insert id="insertBatch" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO ams_admin_role
    	(admin_id, role_id, gmt_create, gmt_modified)
    VALUES 
	<foreach collection="array" item="adminRole" separator=",">
        (#{adminRole.adminId}, #{adminRole.roleId}, 
        	#{adminRole.gmtCreate}, #{adminRole.gmtModified})
    </foreach>
</insert>
```

完成后，在`AdminRoleMapperTests`中编写并执行测试：

```java
@Test
public void testInsertBatch() {
    Long adminId = 5L;
    Long[] roleIds = {2L, 3L, 4L};
    LocalDateTime now = LocalDateTime.now();
    
    AdminRole[] adminRoleList = new AdminRole[roleIds.length];
    for (int i = 0; i < roleIds.length; i++) {
        AdminRole adminRole = new AdminRole();
        adminRole.setAdminId(adminId);
        adminRole.setRoleId(roleIds[i]);
        adminRole.setGmtCreate(now);
        adminRole.setGmtModified(now);
        adminRoleList[i] = adminRole;
    }
    
    int rows = mapper.insertBatch(adminRoleList);
    log.debug("批量插入管理员与角色的关联数据成功，受影响的行数={}", rows);
}
```











